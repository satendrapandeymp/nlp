what's up everybody Chris here with another Chris core is finally back after a long hiatus had a few things going on too threw me off a bit but nevertheless I'm back and I'm ready fried you guys with some killer dev tutorials so this is what we're going to create in this episode we're going to cover how to use HTML cams and JavaScript to first create the effect of circular motion and then once we're done with that we're going to add interactivity this so the spinning portal thing actually follows your mouse wherever you move it creating for a really cool visual effect this is a great way to understand how to integrate both math and physics into code and is useful for things such as game development and creating while with the interactions for your website so without further ado let's go ahead and get started by digging into some of the core concepts when it comes to creating circular motion using HTML canvas we need to own in on a few particular math skills specifically we need to understand what radians are and how sine and cosine functions work if you're new to radians ratings are essentially another way to measure the openness of an angle you're probably used to measuring angles with degrees but when it comes to using math functions built into JavaScript knowing a bit of Radian knowledge will go a long way towards improving your aptitude as a developer so how do we measure angles using radians well one rating represents the openness of an angle in which a circles radius this line right here is equal to the angles outer arc if this outer arc was stretched out straight it would be exactly equal to the length of the circles radius if we start to open our angle more eventually we'll get to the halfway mark which is equal to three point one four radians otherwise known as pi radians and if we go full circle we say that the angle created is equal to two pi radians now the reason we're learning about radians is due to the fact that the two functions we need to create circular motion cyant and cosine only take angles and ratings as their argument sine and cosine are trigonometric functions this is just a fancy way of saying that these two functions take an argument and spin out a result the result a number from negative 1 to 1 represents a ratio produced when two sides of a triangle are compared against each other sine is a function that takes to openness up an angle and radians as an argument and returns to us the ratio produced if we were to draw out a triangle and divide the triangles opposite side by the triangles hypotenuse which is the longest line on a right triangle so if we were to pass an angle of one Radian into our sine function we'd be returned with a ratio of 0.8 4 meaning that the opposite side of this right triangle is 84% of the size of our circles radius if we were to keep increasing the size of our angle eventually your opposite sign would be exactly the length of our radius giving us a ratio of 1 and if we were to keep on going eventually we'll get at the lower half of the circle which will return to us a ratio of a negative value cosine will do the same thing but instead of returning the ratio of the triangles opposite side to its hypotenuse cosine will return to us the ratio produce from the triangles adjacent side divided by its hypotenuse so using cosine here we'll get a ratio of 1 while if we were to use sine here we get a ratio of 0 now since these functions return to us numbers ranging from negative 1 to 1 based on the angle we passed through if we start to increase our angle size over time we start to retrieve all the values ranging from negative 1 1 and if we start to add these values to let's say a circles x and y-coordinates will effectively be producing an oscillating movement which when done right will create the effect of circular motion so with the concepts out of the way let's go head on over to our text editors and let's get coding all right what's up everyone so we are going to learn how to code circular motion so to get started the first thing I'm going to do is I'm going to create a new canvas project I'm going to use an Alfred command that I created to do this essentially all I have to do is type in MK camp or just answer make canvas and then the name of my project like so I think this is 5 because I've done this about 5 times already and then I hit enter and it's going to bootstrap everything I need to get this project opened up in the browser it's essentially making project set up really quickly because setting this up on your own can be very tedious and really I just got sick of it so I oughta mated the task all together you'll see over here in terminal it's currently installing all four dependencies and then once it's done with that it opens up our project and the browser and if you'd like to learn how to do this I recently created a blog which details this whole thing out step by step and regresa getting it set up on your computer the blog post shows you how to do it with three j/s but you can really change out the code for your command so that it also works with HTML canvas boilerplate that I have on github but if you don't want to do any of that go ahead and check out the git repo that I have a description clone it up download all the dependencies these dependencies within it and then run web pack and you should be in the exact same location I am right now the reason we're using webpack is because we can do cool things such as use es6 which is the next generation at javascript and also live reload our page that whenever you make a change over here we have our browser reloaded and you can see I just made a bug so now nothing is working so you'll see that we have all this boilerplate code over here and this is just code that I typically use with an every canvas project that I do so really to get started with creating circular motion we don't really need is HTML canvas boilerplate thing right here at all so we can head down to our animate loop and get rid of see that filled text and if we save that you'll see our browser updates and it is now gone but to create circular motion the first thing we need is some sort of particle on our screen so we are going to be creating a particle object and let's go ahead and get this actually on our screen to get this particle on our screen well we need to create a particle so we have our outline have our blueprint for a particle right here but now we need to actually create one and animate it we need to call this update function to draw it on the screen so we know we're going to have multiple particles because if we look at our example over here you'll see that we have multiple particles running instead of just one and be kind of boring if we only add one here so we want to make sure that we have the ability to create and animate multiple particles at a time so since we know we need to be creating multiple particles we are going to be storing these particles within an array so you'll see right here rekkles that isn't that what I wanted particles we are storing all of our particles within an array but the second thing we need to do is we need to now create particles and push them into an array so to push them into this array we're going to say particles dot push and I'm gonna add a semicolon right here real quick we're going to say particles dot push a new particle and our particle object takes a few arguments takes an x value of Y value of radius and a color so since we want this to be spawned in the middle of our screen we're going to say canvas width / 2 canvas height divided by 2 for a y-coordinate and then our radius let's go ahead and set it something simple for now 5 and let's go ahead and give this a color of blue so if we save that and let's go ahead and console.log things out to make sure that we're actually pushing a particle into our particles array well constant log out particles and you'll see if we refresh the page we now have an array of 400 particles really we only want to focus on one right now and eventually once we understand how to move that one particle we'll get on to adding more so instead of creating four hundred particles we're just going to say create one particle instead so we have one particle but now we need to actually draw this on the screen so to draw this on the screen we need to call the particles update function right here which in return calls this draw function and to do this we're going to head on over to our animate loop we can uncomment this right here because this is how you animate multiple objects at once we're going to say for each of our particles we want to select a particle and with that protocol object we are going to call its update method so as soon as we save this you'll see we now have one particle on the screen which is perfect but now we need to actually get this thing moving and it gives this thing moving in a circular motion well this is where we need to use radians and our sine and cosine functions that we learn about so the first thing we're going to do is we're going to add a new property called this dot radians so the first thing we're going to do is we're just going to get this circle moving in one direction and to do that we're going to be altering the particles x-coordinate and we can say this X is equal to this X plus 1 and you'll see now it is moving to the right but we don't want to just move to the right we want to be moving in an oscillating motion so back and forth back and forth and to do so we need to use a sine or a cosine function so we're going to say instead of adding 1 to this X we're going to say math dot cosine and then our cosine function takes radians for its argument so since it takes ratings for its argument we want to create a new property up here called radians this is going to be equal to let's just say 0 for the time being we're going to pass this through our math that cosine function so there start radians we want to set this dot X equal to Matt that cosine with our radians inside of it which will give us a value anywhere from negative 1 to 1 so if we save this right now you're going to see that our Y value is still equal to our enter height divided by 2 but our x value is equal to either negative 1 or 1 any value between that right now that's not really what we want we want to make sure that our x value is still in the middle of the screen but we want to make sure we're not adding X to itself otherwise it's going to throw the motion off of it so instead of adding this X to itself we're going to reference the particles original positioning and this is going to make sure that we're adding a value of negative 1 to 1 onto the original location of the particle without throwing things out of whack so if we do that you'll now see that we have our particle back in the middle but it's currently not move are doing anything that is because we need to increase our radians over time and as we do that we're going to start getting values from negative one to one so let's go ahead and do that now we're going to say let's go ahead and do this before that we're going to move these points over time by saying this that radians is equal to plus equal to this dot velocity so since we're adding velocity onto this we need to create a new property right here and this is going to determine the speed in which the particle actually moves so we can say this that velocity equal to zero point let's start off with zero point zero five all right so oops excuse me sorry about that so as soon as we go ahead and add this line of code if we look very closely you'll see that the circle is moving ever so slightly but it's so slight it's not even really noticeable we want to make sure that we see obvious motion from the circle so it's moving from a value of negative one to one and we can check this by console logging out our math dot cosine function over time and you'll see it's going from negative one to one back and forth back and forth but like I said we want to make sure that this is visible and in order to do this we want to go ahead and multiply this by a larger value so we're going to say that this is equal to a hundred and actually let's go ahead and console.log this out again so you can get a better idea of what happens once we add this 100 here well go ahead and say console.log math cosine again save this and the first thing you notice is that our circle is moving left and right in a much larger motion it's moving between values of 100 and negative 100 and we're still seeing the same thing right here because we're not actually multiplying this function by 100 right now but as soon as we add it you'll see now we're sifting between values of 100 to a negative 100 and whenever we add this on to the X's our Protocol's original x-coordinate and set the particles new x-coordinate while it's creating this oscillation effect as a result this is the first step to creating circular motion but the step is we want to alter not all our x-coordinate we want to alter our y-coordinate as well so we're going to say this dot Y is equal to Y and you may think as soon as we add this and save things that'll work but once we save it you'll see that circle is actually moving in a diagonal direction that's not what we want the reason for this is because we're using cosine and two spots in order to get that circular effect we need to use sine instead and as soon as we add sine there you'll see we just created the effect of circular motion so really this is all there is to it the most important thing I want you to remember is creating circular motion all comes down to these two function right here and incrementing the radians that you pass through it and once you add that and add it to an X and y coordinate while you then get the effect of circular motion but this isn't we're not then just yet we want to create exactly what we saw with an example over here we want to create something actually has multiple particles particles that follow the mouse on movement kind of with a drag effect we also want multiple colors on these so let's go ahead and do that now first thing we're going to do is create multiple particles instead of just one it's going to delete this constant log statement and let's go ahead and add multiple particles to and multiple particles will go down to an it and say we want to create 50 particles instead of just one so we created 50 but you'll see that the issue is all 50 particles are being drawn on top of each other instead of different locations around here so the reasoning for this is we are currently spawning all of our particles on one path within the circle we're going to fresh the page you'll see that all of our particles are being spawned right here at zero because that is when a circles angle is equal to zero radians so instead of spawning our particles and one point where radians are equal to zero we want to make sure that we're spawning our particles anywhere along this circles path and I do so we want to add a math dot random value here instead of a hard-coded value of zero and we want to say get a random value anywhere from zero to math PI times two because math PI times two is when an angle travels all the way from one side a circle back around doing a full 360 loop so we are going to say math.random times math pi times two as soon as we do that you'll now see that we have circles being spawned in different locations on the screen now this is the first step to creating that cool little effect that we had an example but really the issue here is that all these circles are being spawned with within the same distance from the center we want to make sure that they're being spawned and random distances rather than the same one so to spawn these circles with random distances from the center we don't want to spawn them with a hard-coded value of a hundred we want to spawn them with a random value instead let's just say anywhere from 50 to 120 so to get a random value we're going to use this utility function right here random int from range we're going to say get a random integer from 50 to 120 for x-coordinate we're going to save that you see that we get this really wild result going on right here and the reasoning for this is because each time we run this update function we're essentially getting another integer we're generating a new random value which ahead and throws everything off it doesn't really give us a smooth motion like we want we want to make sure that we're generating a random value but we're only generating it once rather than each time this update function is ran so instead of using this function with an update we are going to set this distance from Center and this is going to have both an X and a y property within it so we're going to set both x and y Eagle to a random integer from a range of 50 to 120 and now we need a reference this within our circular motion path and let's go in and comma the set real quick say that this is circular motion right here so we want to go ahead and multiply our circular motion by distance from Center it's not distance from Center X and this is going to go ahead and randomize our circles distance from the center of its spawn location so let me save this you'll see that we have an error somewhere let's see unexpected token okay so let's see where is this all right so the error is I never set an equal sign right here and once we save that you now see we get a really wild looking effect here and this is actually pretty cool I wouldn't probably pursue this myself if this might this might end up being cooler than that effect we're actually going for but if we're gonna if we were to go off the example this isn't really what we want we want something that has the circles moving in a smooth path but right now they're kind of going in a 3 be looking path and the reasoning for this is due to the fact that we are only we're currently only referencing our x coordinate but even if we start referencing our y coordinate over here within our Y circular motion function we're going to see we just kind of further three B is our canvas piece right now so really the issue here is that we're generating or in a value a random distance from Center for each of our circles for both x and y when we really want to make sure that both x and y have the same random value rather than different ones to fix this we're just going to go ahead and delete this object altogether we're going to say random int from range 50 to 120 so we only have one that's being generated then we get rid of the X get rid of the Y and as soon as we do that this is the motion we're going forward this is the distances from the center that we want in order to create that example effect so next thing is going to be actually creating the trails that we saw as well so to create a trail effect is actually pretty easy we're going to go ahead on down to animate instead of using clear rec this is the function that refreshes the screen gives us a new slate to draw on each time we call particle dot update you'll see if I comment this out right now save it our circles are just drawn on top of each other and we don't actually get that we don't actually get the screen clear at each time this animate loop is ran instead of using clear rect we are going to use fill rect and we're going to set our fill style equal to a value of rgba 255 255 255 which is going to be wiped we're going to give it an opacity of zero point two zero five and as soon as we save that you'll see we now have a trail effect so how this works is we're essentially creating a rectangle to be drawn on top of our circles each time we run this animate loop so for each frame we're drawing a new white rectangle on top of it and that rectangle has a very slight transparency which once we start layering each of these transparencies on top of each other we start to get this trail effect as a result but it's not this isn't really the trails I would say we're looking for if you look closely you'll see that these trails have ridges on them and that's due to the shape that we're drawing within our draw function since we're using an arc to draw this it creates knots and not so smooth effect not the smooth effect that we want so instead of using an arc we're actually going to be using a line instead so let's go ahead and delete our arc our fill style and our fill and we're going to say C not move too beneath that we're going to say see it online too and then finally we're going to say see that stroke and I should actually specify we need to set our stroke style equal to the color of whatever we set our particle to so this is going to be equal to this dot color and then we need to set our line width equal to our radius okay cool so see dot move to Hawaii did behind creating a smooth looking trail is we're going to be taking our particles previous location within the previous frame and then drawing a line to the particles new location in the new frame so you can see right here see that move to this is going to take the coordinates for the particles previous frame and this is going to take the coordinates or the particles new frame so since we know that this is going to be the particles new location we're going to say this X it's not Y but we need the old particles location so in order to do that we need to grab it from this dot update and we're going to create a new variable called last point this is going to be equal to X Y X and then Y is going to mEagle do this dot Y this is going to give us the particles last point before we actually edit anything because you'll see right here this is where we edit our X and our Y value but since we're storing this within the last point variable right here before we edit anything well we're essentially getting the last point of where our particle was so if we go ahead and pass this into our draw function and since we're passing it in and we need to make sure that we're adding it as an argument right here we can go ahead and access last points x value and the last points Y value and as soon as we do that you'll now see that we have a smooth looking animation here much more smoother than if we were to use that circular effect it's still not looking exactly like we want at the and one of the reasonings behind this is because we want to make sure that these are being spawned with different radii different radii sizes so to do so we currently have a hard-coded radii of five for all of our particles we want to make sure that this is randomized so we're going to say for each time this for loop is R and for each individual particle give us a new radius that is randomly generated between let's just say the size of one to two better get a size of one to two we want to say math dot random which I'll go ahead and give us any value from zero to one multiply it by two which will give us any value from one or excuse me a zero to two but we want to make sure that this is only from one to two we're gonna wrap these in parentheses add one onto the end and this will go ahead and give us a value anywhere from one to two rather than zero to two we take the radius replace five with the randomly generated radius you'll see now our particles are actually being spawned at slightly different sizes and this creates a much smoother looking particle trail as a result alright cool so we have this going on let's go ahead and colorize this because our blue color really isn't cutting it out we want something a color scheme or something that makes things look a lot better so I'm gonna go ahead and copy over the color scheme I have over here you can go ahead and copy and paste these colors as well if you'd like to use them or you can use your own color palette replacing these hexadecimal values with whatever you'd like I'm going to go ahead and take these colors in this color array I'm going to use it within this random color function this utility function right here this is going to return a random color from an array of colors which we already created and we're going to say instead of using blue get a random color from our random color array and if we save that now we have our colors being outputted over here in the browser and we are really close to creating when we have over here and this is looking pretty darn cool I would say but the next thing is we need to create this mouse movement effect we know how to create circular motion we know how to make things look pretty cool but we don't have any interact at the moment so to add the interactivity we need to make use of our mouse or Mouse's X&Y coordinate which we're already setting within this event listener right here but now we need to actually make use of this X&Y coordinate so to make use of this we need to make sure that whenever we move our mouse that the X&Y positioning of our circle or the center of our particles is moving along with the mouse so instead of saying instead of referencing X as our initial coordinate we're going to reference mouse X instead and instead of referencing the initial Y location we're going to reference our mouse's Y location instead as well so once we do that you start moving things around and you'll see that it's now following our mouse wherever it goes super simple but as we move it you'll see that we're getting a really jagged e effect and it's not really anywhere near as smooth as we saw with an example this is because the center of the particles are moving along with the mouse real time rather than creating a drag effect which we need to add a little bit more extra code to to achieve so to create the drag effect we need to do something similar to what we're doing right here to create the particle trail create the particle trail we're connecting the particles last location with the new location to create the drag between the mouse and the center of our particles we need references our Mouse's previous location and our Mouse's new location so in order to do that we are going to be creating a new property to reference our Mouse's last position we'll say this that last Mouse is equal to X where we initially spawn the center of our particles and Y so this is where mouse is going to start but now we need to actually create the drag effect so this is where we're going to create the drag effect right above where we're actually sending our X in a y-coordinate so we want to say this dot last Mouse it's going to be equal to Mouse X minus this that last Mouse that X times a percentage so we want to say times 0.05 all right so how this works is we are getting the difference between our mouse's current x-coordinate and our mouse's previous x-coordinate so let's say we have our mouse up here in the top left hand corner excuse me I'll go ahead and scroll back down real quick let's say we have our mouse in the position of top left hand corner over here an exposition of 0 if we were to move our mouse over here to a position of 100 well then I'll go ahead and equate this right here to a value of 100 the distance of between our Mouse's previous and new location is 100 pixels if we were to multiply that by 0.05 that means the center of our circle isn't going to move by a distance of 100 right off the bat it's only going to move by a distance of 5 pixels instead so instead of moving by 100 pixels removing by 5 and as a result since we're only moving by 5 we're going to get a nice trail effect where this is dragging instead of following our mouse exactly so instead of referencing our mouse that X we want to reference our Mouse's last x-coordinate instead so if we paste that in there now you'll see whenever we move our mouse along the x-axis that we have a nice trail effect as a result but it doesn't really work for our Y at the moment that's because we need to do the same thing for our y-coordinate as well so we're going to say last mouse Y mouse Y and last mouse Y and then we're going to replace our current mouse coordinate with this last mouse Y save things and now we have the super nice smooth trail effect that we are going for and I think we just completed the tutorial this looks really cool it's a really nice effect to create a circular motion a drag effect really play around with the colors of this and even the coordinates and randomization stuff you can come up with really really cool things just by randomizing different values within here I really recommend it but this is how you create circular motion this is how you get things moving with drag this is how you create trail effects to create something that you can be proud of something that you can show off to your friends or put on your website so I hope you guys enjoyed it it's been quite the lesson we covered radians we cover it sine would cover cosine a little bit of trigonometry if you enjoyed this video go ahead and leave a like subscribe feel free to donate to me a patreon I currently do not make anywhere near enough money so myself on doing this full-time so every patreon donation I get does help a lot because I can put more time and you're creating these videos for you guys if you guys have any questions all about the video the code that we went over the math behind it feel free to leave a comment or go ahead and reach out to me on Facebook Twitter any method to reach out to me and I'll be sure to answer otherwise I hope you guys enjoy it and I look forward to seeing you in the next video peace [Music]		