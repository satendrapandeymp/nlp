welcome back everyone this is going to be episode four of our become a canvas pro course where in this episode we are going to be learning how to interact with the canvas so we know how to resize our canvas we know how to draw elements on it we know how to animate those elements but we don't know how to add interactivity with our canvas so that when we hover over the canvas where when we click on it or when we put our finger on our phone or so forth we don't know how to actually get these elements to interact with the events that are occurring on the screen so this is the end goal we want to be able to produce something cool like this where we have animation our balls bouncing off the edge of the screen but at the same time our circles are growing as they come in contact with our mouse so this is going to be the end goal and this is what we're going to produce by the end of this video so where we left off let me go ahead and exit out of this tab this is where we left off we have a bunch of large black circles bouncing off the edge of the screen and slow motion so we have a little bit to go we have to change size of those circles randomly we have to change their colors randomly and we also have to add the interactivity I was talking about so first thing first let's go ahead and add that interactivity to add interactivity to your canvas piece you're going to need to know one important concept and that concept is event listeners so if you haven't heard of an event listener basically it's a function that's going to be fired over and over again as long as an event is occurring on the screen so let's say my event is mouse movement if I'm moving my mouse like I am right now we're basically going to be calling a function within our JavaScript and that function is only going to be called as long as the event is occurring so only when I move my mouse and there are a multitude of different events we can call we can call things such as mouse down a click event we can call it mouse up event and we can also call touch event for mobile devices so to create an event listener we are going to go into our code color window and add an event listener like so so this takes three arguments but we really only need to focus on the first two we first need to clear what type of event we want to monitor we want to monitor our mouse's position whenever we move it across our screen so in order to monitor our Mouse's movement we are going to put in mouse move as the event we want to monitor so now that we know which event we want to monitor we now need a function to call whenever this event occurs so we can insert a function names such as anim if we were to put our n may function in here but that one it really makes sense it's much easier to just add an anonymous function so we are going to do that instead so now whenever we move our mouse across our canvas this event this function is going to be called we can test this out by inserting console.log statement put some dummy text in there fresh the page move your mouse around you'll see that our console.log statement is being out put it in the console over and over again as long as we move our mouse only when we move our mouse if we stop it's not going to be incrementing but when we move our mouse you'll see that's being called over and over and over again so basically in order to get these circles to interact with our mouse whenever we're moving it we need to take into consideration some geometry we need to get the distance between our mouse position and the distance between each of these individual circles and if the distance between our mouse position and each of these individual circles is let's say less than 50 then we want to make sure that circle is growing and if it's greater than 50 we want to make sure that the circle shrinks down back to its original size so if we want to get the distance between our mouse position and one of these circles then we first need to get our Mouse's position and we can do that through our event listener over here this anonymous function always has what's known as an event argument so within the phenomenas function all we're going to do is add an event argument and if we consul on this out move our mouse you'll see that we actually have an object being returned to us and these objects represent all the data that are associated with our event as it's happening on the screen so you'll see that when this event occurred our mouse was at an x position at 226 pixels and our y-coordinate was at the position of 239 pixels and if we look inside another one of these and scroll down you'll see that x and y values are different because our mouse is at a different position as if that was being called you'll see that we just keep creating more and more event objects as we move our mouse across the screen so with this event argument this event object we can go ahead and grab the x and y values of the event that is occurring and we're going to use those x and y values to compare them to the decision of the circles on the screen and once we compare them to the position of the circles on the screen that's when we can calculate the distance between our mouse position and the actual x and y values of the circles so since we first want to get x and y value of our mouse we're going to be creating a mouse object like so this is going to have an x-coordinate which at first is going to be undefined and a y-coordinate which is also going to be undefined we don't want to set this just yet we're going to set this within our mousemove event listener so our mouse that X is going to be equal to our events that I believe let's go ahead and look inside our object to make sure we're selecting the right thing it's going to be equal to our event X property the same thing is going to go for our Mouse's Y property it's going to be equal to our event Y is property and we can test this out by console logging our mouse object fresh the page you'll now see we have an object with just an x and y coordinate and we are going to use this as I said to compare it to actual positioning of each individual Circle and if the distance is less than 50 the circle is going to grow so now we need to compare it to each individual circles coordinates so we are going to go head on over to our update function we are going to add another conditional below all of our velocity and wall balancing stuff here so we are going to say this is where the inter activity occurs with the comment so the first thing we need to do is we need to get the distance between our Mouse's positioning and actual circles positioning so to do that all we need to do is select our mouse is x-coordinate and from our mouse is x-coordinate we are going to subtract each individual circles x-coordinate and if this is less than 50 we want to call a function so first we need to create conditional make this conditional at least and that should be good to go so if this is less than 50 we want to grow the radius of our circle so we are going to say this that radius plus is equal to 1 and now let's watch what happens when we refresh the page we start moving you'll see everything to the right starts growing sporadically and there's really no control here we only want to track what is within 50 pixels within our mouse's positioning so this isn't good enough this isn't going to cover all of those use cases all the conditions we want to track in order to ensure that happens so right now all the circles to the right of the mouse are growing because let's say let's say that this X is equal to 200 well our mouseka X is equal to 100 well if that's the case we are going to get a value of negative 100 and obviously that's going to be less than 50 so that means that all the circles to the right of our mouths are going to be growing by one we need to take into account that we don't want that to happen so as a result we are going to add an or or excuse me an and operator and we are going to say it's mouse to X minus this X is greater than negative 50 then we are to grow its radius by one so let's go ahead and see what happens with that so now not everything to the right of the mouse is going to grow just whatever is within fifty pixels of our mouse from the left or the right but the issue is refresh the page again you'll see everything to the top and the bottom of the mouse is still growing so we need to take into account as well that the circles above and below our mouth should only be 50 pixels within the distance of the mouse so right now we're only tracking our x-values we need to take into account our y-values as well I'm going to space this just to give us some space so let's go ahead and fullscreen this to the better show you the conditional going on here we are going to add another end operator and we are going to say only increase the radius of the circle if Mouse that why - the circles y-coordinate is less than a distance of 50 but we also need to have taken to account the negative numbers so we need to say only increase the radius of circle if the mouse Y - this dot Y the distance between the two is no less than negative 50 and let's go ahead shrink this refresh the page now you'll see only in the circles within 50 pixels distance of our actual Mouse are going to be growing but it still leaves us with a bit of an issue these circles keep growing and the ones that aren't 50 pixels from the distance of the mouse they don't actually shrink as they should be within the demo I show you earlier so that's something we'll also need to take into account is what happens when this conditional is not true and we can test what is not true by adding an else statement at the end of this and when this is not true we are going to decrease the radius each individual circle by one so basically all the circles are shrinking to the point where they're not even visible and we get a bug within the console now this is happening because this conditional is not true so we're actually subtracting one from the radius of all circles until they equal zero so we need to make sure that these circles do not decrease past a certain point so instead of just doing an else statement we are going to add an else if we are going to say only subtract one from the radius of circle if this dot radius is greater than two so this way the radius of circles the radii of circles they won't actually go into nothing they'll at least be two pixels wide and radius once they go outside the distance of our mouse so now you can see when we're hovering over these but the circles don't go back to their original size they go down to a smaller size as specified here this is the size that they're shrinking down to but at the same time they're still kind of achieving what we wanted to in the first place we're hovering over it's circles and they're growing to a certain distance and as we hover out of them they're going back down to a specified size so to achieve the same effect I showed you with in the demo we need to ensure that these circles don't expand past a specified limit as they grow so this is going to go within this conditional right now this conditional is managing when the circle should grow when the mouse is within 50 pixels of each individual circle so to ensure this we are going to not add on to our current conditional because that is already quite lengthy we are going to be adding a new conditional within this we're going to say only increase the rate of each individual circle if each individual circles radius is no greater than let's just say 44 now then we'll grab our increment radius code and place it within this new conditional so now if we refresh the page and we hover over these you'll see that the circles now have a max limit in which they can grow too they can't grow past this limit because we added this new conditional and for good coding purposes it'll actually be good to transform this 40 and do something that is more understandable so instead of just saying that make sure the radius does not grow up has 40 we're going to say make sure that the rate is is no greater than max radius specified as a variable we can specify a variable up top let's just do it right beneath our mouse object there max women is that what we call it max women max radius our max radius is going to be equal to 40 and this is max radius in which our circle should grow too all right so now we're following some better coding conventions because we're specifying what our max rate a should be instead of just having an arbitrary number within this conditional the same thing for our minimum radius let's go ahead and add that in here as well so we'll say instead of two men radius and right beneath our max radius let's go ahead and add a min radius of yeah let's just go ahead and do two for now all right so we have more readable code now but there are still a few things we need to do here in order to get that nice aesthetic that I showed you within the demo so some of the things we need to do here are change up the colors of these circles and to change out the colors of these circles we need to do a little bit of math here it's a little interesting topic we need to create what is known as a color array and this is just going to be a ray that stores all the colors we would like our circles to be if we wanted our circles to be randomized between five different colors our circle array would contain five different objects and with endings we'd specify hexadecimal values that will represent individual colors so let's just go ahead and put some random colors in here for now and then once we actually want to make this thing start looking good that's when we'll go ahead and over to website called cooler which will go ahead and give us color palettes and we can use the hexadecimal values from there to give us a nice look instead of just randomised colors as we're doing right now all right so now we have an array of colors but now we need to actually enter these colors within each individual circles fill property so let's go ahead and check out where we're drawing our circle right now you'll see that we have a stroke style we have a stroke and we also have a fill let's go ahead and get rid of our stroke style for now so we just have a fill see that we just have black circles at the moment with no stroke we need to change the circles fill style for each individual circle and each fill style is going to be equal to one of these options within this color array so how do we randomly select a color from the color array well first we need to access a color array then we need to specify a random index so we need a number from 0 to 1 2 3 4 we need to specify a random indices from 0 to 4 because we start counting our arrays at 0 so how do we get a random number from 0 to 4 or at least the length of our array well it's little it's a little tricky for beginners but this is how it's going to happen we need to get a random number so we are going to use math dot random we need a random number between 0 and the length of this array and the length array is going to be 5 since there are 5 different elements in here let's go ahead and test that out really quickly let's just go ahead and cancel out our color arrays length excuse me that's just console logging our color right we want to specify our length you'll see the length of our array is 5 this is how many elements are within our array so we want a random number between 0 and the length of our array which is going to be 5 and we're using color array dot length because if we wanted to add more colors on to this color array dot lengths will take care of any calculations for us so we don't need to get rid of those and just specify we have 5 colors with an array or 6 colors and so forth color array will automatically take the number of elements within an array and do any calculations you need in the process to get a random color all right so we are specifying get a random number between 0 and 5 but this will give us decimal numbers if we're actually run this in the browser you'll see we're not actually getting any colors and that is because right now this whole function that we're doing with math.random a color array dot length is giving us a decimal value so we want to make sure that we're getting a whole number so we can access each individual index within this array so to get a whole number we are going to use another function called math.floor and we are going to wrap our whole multiplication function within this so all math.floor does is it gets the lowest whole number closest to the value that's outputted so if I were to get a value of 0.5 math the floor would take that value and transform it into 0 since that is the lowest whole number right beneath the value let's say my number were 1.2 if I were to put that within matha Florin well my end result would be 1 same thing goes for something like 3.8 if I were to get 3.8 we get the lowest value beneath that and Lowe's whole number which would be 3 so with this in place we should get random values random colors as our circles and you'll see that we actually have a pretty wild effect going on here this is a lot that goes into canvas is just experimentation and right now this is happening because we are calling this draw function every single time within our update function right at the bottom here we are calling draw and since we are calling a random color from our array over and over again with notice draw function well the colors are changing dynamically over and over again as well so we want to make sure that the colors of our circles aren't only set once rather than set over and over again within this draw function and to do that we are going to take this function right here that we wrote we're going to add a new property to our circle called color this is going to be equal to random color from our color array so our fill style is then going to be equal to this color and that should fix the issue of our blinking circles and it does so now we have some nice-looking colors here some randomized colors and we are going to change these up to a nicer color as soon as we finish everything else but go ahead and play around with this so somehow every episode play around to change out the colors a bit go ahead and change out the randomization stuff see what you can do and just what kind of cool stuff you can produce because it's really fun and it's what's going to help you learn the most in the long run all right so we're almost done here we need to now randomize the actual sizes of our circles so as you can see all of our circles right here they are all very small and they're all very uniform we want to make sure that the circles that are bouncing around our random sizes to give it a little more variety a little a little more of a randomized field for actual canvas piece so two randomized actual minimum size of the circles we are going to be giving our circles radius a random number so all of our circles radii they are being declared within this for loop down here and you can see that we just hard-coded in a value of 30 for our radius so instead of a value of 30 let's go ahead and do math dot random and let's say that we want a random value from one to let's just say four for now and to get a random number one through four instead of zero through four we first need to get a random number zero through three so we're going to say math not random times three and then once we get a random number zero through three we are going to add one on to the end of this so how this works is if we get a lowest value of zero random number zero through three well then at least we'll be adding one on to that so we know that we're getting a minimum radius of one and if we get the highest value of math dot random times three which will be three we're adding one on to that as well so we're successfully getting a range one through four rather than just a range of zero through four so we want to make sure our circles aren't that small you want to make sure that have a minimum radius of that least one so this should make things look a little different over here and you can see that indeed they do are some of our circles are smaller very slightly smaller than the others and it's kind of giving it a nice variety compared to what we had before but if we start hovering over these you'll see that eventually the circles become uniform again and that is because we have a set minimum radius a hard-coded minimum radius up here which says that the minimum radius after circle grows and shrinks back down is going to be two so it's not actually shrinking back down to its original size that it was set as it's actually shrinking back down to the set value that we put here with a minimum radius of two so we want to make sure our circles shrink down to their original radius rather than a set value as we had up here so to do this we are going to be creating another property this is going to be called this that min radius so each individual circle is going to have its own minimum radius because one circles minimum radius it's starting radius could be one while the other could be three the other could be two other could be 2.5 we want to make sure that each individual circle has its own minimum radius so it shrinks down to what it was originally set so instead of setting it to something like minimum radius we're going to set it to the circles of original radius so this not radius right here it's going to be altered by these conditionals it's going to be increasing and it's going to be decreasing depending on the Mouse's positioning but this Gunmen radius is not going to be altered at all we are going to say keep decreasing the size of our circles as long as the circles radius is greater than each individual circles minimum radius and with that in place you'll see that the circles actually shrink down to their original size and not one uniform size so we're actually adding some nice variety here's some clean code and some stuff that's ensuring that our circles are going back down to their original size so assume that this is good but it's not great at the moment there's still a lot of white space here and it's not that it's not that appealing to me in my eyes so let's go ahead and add more circles to this let's go ahead and bump this up to 800 that should be good don't have to mess around to see how many circles you can add without crashing your program let's go ahead and refresh this and you can see this is a lot more interesting especially when we actually make this full screen like so and that presents an issue when we make this full screen is why isn't the canvas actually being responsive to the width and the height of our browser well that is because we need to add another event listener specifically for resizing our browser window so right now we have an event listener of mousemove let's go ahead and add an event listener of resize this is going to be called whenever the browser is resized so we need to function the call over and over again whenever we resize our browser and now we need to do a few things to ensure that our canvas is full width and height of our browser each time we resize it we ensure that all we need to do we need to grab this original code that we wrote from the first episode which resized our canvas width and height based on is first refresh and we want to make sure that we're calling this canvas resize code every time the browser is resized so this will ensure that the canvas is always going to be the full width and height of the actual browser and if we refresh this and start dragging your browser you'll see about the canvas is actually extending but our circles they're starting to move over into the other side of the canvas but they're not being there not being generated dynamically over here when we actually resize the browser so to ensure that the circles are being generated dynamically each time the browser is resized we need to add a few initialization techniques to or event listener so what's going to happen is we are going to call a function called admit each time we resize a canvas but now we need to create an actual function called min so right above our anim function we're going to say function and then and within this we are going to basically be resetting our circle right we're basically going to be calling all this in here over and over again each time you resize a browser we're basically just replacing all the circles generating them in new positions so that they're always going to be filling up the entire screen so let's go ahead and grab this code paste it within our net function and since we're putting this within a function we need to make sure that we're actually calling it so it can be generated the first time press the page and you'll see that we have an issue and let's go ahead and check out our console to see what's going on here you'll see that circle array is not defined and that is because the scope of our circle array is currently only within this init function let's go ahead and make sure that we're taking it out there press the page and let's see what happens when we resize our browser and you'll see that we're generating multiple circles over and over again and it's starting to get pretty laggy in the process let's go ahead and refresh that and find out what's happening so each time we're calling an it we're calling in it each time we resize our browser since we're calling in it over and over again supposed to generate 100 circles and cells of pushing 800 circles into a circle array we're not actually resetting our circle right back to zero we're not actually resetting it to a clean slate we're just adding circles on it on to the end of the array so make sure now we're resetting it to a clean slate we're going to say circle R a is equal to an empty array right before we call all the circle generation code right here and if we do that you'll see that six is our issue and circles are being generated dynamically as we go about resizing our browser which is exactly what we want so to finish off this episode let's go ahead and choose a better color palette so we get something that's more interesting a little more eye pleasing than what we have right here my website of choice for choosing color palettes is called cooler and you can just type cooler into Google and within cooler you can click the explore button explore different color palettes that people have created so you'll see that we have a number of different color palettes here you'll have most views most popular all themes we just really go through here these are really well picked out color themes for the most part pick something that's going to be eye appealing to you personally I think I like this one this is very similar to why I had an original demo so I'm going to choose this one and to get the color values for this color palette right here all we have to do is click Edit copy and you'll see that each of these individual colors has a hexadecimal value beneath it right here so if I wanted my circles to be blue I can just go ahead and grab this go back to my color array and paste it there and we're just going to do this for all of our colors we're just going copy paste copy paste and we're almost there copy paste copy paste alright so now we have which should be a better looking color palette than before if we check this out in the browser you'll see that this is a lot better looking than it was this is a lot more professional-looking as the colors were hand-picked the blend and give us a more professional vibe so we now have a full-fledged canvas piece that takes animation interaction and browser resizing into consideration we also know the four basic skills required to become a canvas pro you should now have a solid foundation that you can use when developing any interactive canvas piece in regards the next steps try replacing the art drawings with points lines rectangles and even images tried different randomization techniques see what other conditions you can add make objects react with your environment there's a lot you can do here a lot to experiment with just ticket into your own arms really see what you can do here to produce some badass canvas pieces so that's going to be it for this one folks I hope you enjoyed it learn a lot lightweight regards to future canvas courses I do have a bit more plan out there to learn how to cover it's with one-off cameras animation kind of make a bunch of particles on screen crack to a certain point how to create html5 canvas game so stay tuned ecolo thanks for tuning in and I look forward to seeing you in the next episode [Music] you [Music]		