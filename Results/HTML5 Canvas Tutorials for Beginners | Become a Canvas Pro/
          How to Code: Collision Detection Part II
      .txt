what's up everybody know there's been a long wait on this video saw a few comments on the previous one asking where it is and I didn't want to leave people on an eternal cliffhanger so here we go this is what we're going to be building with in this episode you can see that we're using collision detection to determine when these particles collide and then we have some code that says what they should do when they collide in this case that is bounce off of each other we're also going to be adding a bit of interactivity that's to make sure that we have something that's interesting and fun to play with you'll see that whenever I move my mouse over here we're actually filling in the particles with their outside color which is a pretty cool nifty effect so getting us to work is little trickier than you may think so let's get right onto some core concepts and learn how to achieve this effect we know how to detect the collision of just two objects but the question remains how do we react to these collisions well there's a multitude of possibilities but one of the most interesting and straightforward things we can do is have these objects bounce off of each other in a realistic manner learning how to do this will better your understanding of simulating physics effects within code and can be used towards production of games and interactive web art so what is the process behind achieving this effect well first we must ensure that whatever objects we spawned that they're not being spawned on top of each other if two objects are overlapping within our simulation they're not going to be able to move since our collision detection code will assume that they're constantly colliding second for each particle we must calculate the distance apart from themselves and every other particle on the canvas we want to make sure our particles know that they should collide with every other particle on the screen so we need to create some sort of way to monitor this third once we're able to determine when these particles have collided we need to have them react in a realistic manner to do so we're going to be using some utility functions that give us a realistic bounce effect and this is more than just swapping the particles x and y velocities on collision we actually have to use some complex math that determined the exact angle the particles have collided and how the particles should react accordingly finally we'll add some code for interactivity and what that complete will have a wicked canvas piece with particles bouncing off of each other in a realistic manner so let's head on over to our text editors and let's get started welcome everybody so let's go ahead and get started on creating this canvas project so to create a canvas project I use an Alfred command that I created not too long ago to go ahead and spin everything up that I need to get started with canvas development so all I have to do is type NK can and then the name of the project so I'm going to say this is collisions - seven and I'm going to hit enter and this is going to go ahead and run all the terminal commands I need it's going to open things up in my text editor and then finally it's going to open up this project within an actual browser window and this is just a nice way to automate the process of getting all this set up I just like getting things started really quickly which is why I use this and if you would like to learn how to do this yourself I do have a tutorial in a blog post which will show you how to get things set up the blog post is dedicated towards three Jaso getting a three GS scene set up really quickly like you see right here but you should be able to alter things just with canvas and the canvas boilerplate I created on github to get things up and running with this alright so you'll see that over here in a browser window we have our HTML canvas being read because we have this text on our mouse and if we look within our source directory we have all of our canvas code so let's go ahead and get started with actually getting some particles on the screen to get some particles on the screen we're going to head down to our object blueprint right here we're going to change this object to particle and this particle has an x and y-coordinate a radius and a color and we're drawing this particle each time we call this update function this update function this is where we're actually going to be moving all of our individual particles properties so now that we have a blueprint for a particle let's go ahead and start creating some on our candidates over here we're going to create them within this and knit function so we're going to say instead of using objects we want a place to store all of our particles and we're going to store all of our particles within an array like so all right so now that we have a place to store our particles we now actually need to push particles into our array so we can then draw them on our screen so what we're going to do is for 400 times we are going to push new particles into our particles array by saying new particle and the arguments for this particle are up here so it takes an XY radius in color and we want to make sure that our particles are being spawned randomly on the screen so the first thing we're going to do is say Const X is equal to math dot random times our screens enter width and this is going to give us a random according to anywhere from zero to the width of our screen and then we want to do the same thing for our y-coordinate so we're going to same at that random times instead of in or width we are going to say enter height and then finally we need a radius so we'll say radius is equal to ten just to get started and then we need i forgot we need a color as well so we'll say color it's equal to blue just to start things out and now that we actually have all of these created we can pass them through into our particle constructor and we should get some particles being placed within our particles array so we'll say X Y radius and color save that and then when we console.log out our particles we should see four hundred particles in there all right so I'm going to open up our console and you'll see we now have four hundred particles each with their own individual X&Y coordinate that is being randomly generated right here so we're not actually seeing anything on the screen just it and that's because we need to actually render these particles we created them but now we need to actually draw them on the screen we can do that by heading on over to our animate loop and we are going to call articles part of soil particles and for each particle we want to select our particle and for each particle we want to call that particles update function all right so we're going to go ahead and delete this filled text property right here and if we call that you'll see that now we're calling update for each of our individual particles within our array an update will go ahead and return call this draw function which draws it on the screen so we have particles being drawn on the screen but in order to create that collision detection between all these individual particles we need to make sure that these particles are not being spun on top of each other why well if they're spawn on top of each other our code is going to list them as always colliding which means we're going to be stuck together and they're not going to get a realistic bounce effect so to better illustrate this concept instead of using a fill style we're going to use a stroke style and we are going to call stroke instead of fill so once we save this you'll see that we have tons of different overlapping particles right here so let's go ahead and fix that let's make sure that our particles are not being spawned on top of each other so to fix this we're going to go down to our net function right here and instead of generating four hundred particles let's just focus on let's just focus on a few let's focus on about four of them right now so we have four particles and let's make them a lot bigger let's make them yeah okay that looks pretty good to me so we want to make sure that these particles are never overlapping on top of each other well what do we do to fix that well here's the idea within this for loop we are generating random x and y coordinates for each of these individual particles so we go through this once we create a new X and y coordinate and we push a new particle into our particles array well the second time we go through it we create a new X and y coordinate and if that X and y coordinate is within a certain distance of the coordinate before it the one that's already within this particle array well we need to regenerate this X&Y coordinate so that it's placed somewhere else on the screen so we need we know that we only want to do this for the coordinates that come after our initial particle because if we only spawned one particle on the screen while there's nothing there's no other particle to compare it against so we need to make sure that we have at least two particles on the screen and then we need to start comparing particles distances between each other and make sure that they're not less than zero and if they are less than zero we're going to regenerate them place them somewhere else on the screen so let's go ahead and do that now first thing we're going to do is we're going to say if I is not equal to zero so this is going to skip over the regeneration process for the first iteration because we only have one on the screen but for all of our other particles we're going to loop through all over particles the particles that length and we're going to be using J instead of I because we want to make sure that these two are different so we're looping through all the particles that already exist so for all the particles that already exist compare their location to the randomly generated location that we have here within our X&Y coordinates so to do this we're going to be using that utility function we created within the last episode I changed it up a bit I'm calling it distance here and it takes an X and a y-coordinate and another X&Y coordinate so we're going to be comparing the distance between this coordinate and this coordinate right here within this for loop so what we can say is if the distance between x and y are randomly generated coordinates and the distance between the particles that have already been created so particles J X particles J dot why if the distance between these two is less than zero and now remember we need to take into account that these circles have radii associated with them so to take that into account we want to make sure we're saying radius times 2 minus radius times 2 sorry so we're saying if the distance between these two is less than 0 if they're overlapping then we want to regenerate our X in our y coordinate so what we're going to do is we're going to take this hast it with our if statement let me go ahead and fullscreen this you can see it a little better get rid of the constants we don't really need those right now so we already declare things up here and since constants make sure that your variables cannot change later on we want to make sure that we change these to lead because we might be changing them later on within this for loop if required if they are overlapping all right so once we do that we now have a way to randomly regenerate the coordinates in case the particles are overlapping but you'll see that we still have some overlap here and the reasoning for that is even though we regenerate some new coordinates these newly generated coordinates might be overlapping on top of particles anyways so what we need to do is once we generate these new ones we need to restart our loop all over again to make sure that these coordinates are not equal to whatever particles already exist on the screen so to restore our loop over again we're going to be setting J right here we're going to be setting it equal to negative 1 and we're not setting this equal to zero like we are right here because remember once we go through this for loop we're adding one on to it which means we're starting off at one rather than zero like we want so we're sending it to negative one and that is going to make sure that things should not spawn on top of each other so you'll see that they are still spying on top of each other let's go ahead and do some quick debugging to figure out what is going on here and if we look closely within our for loop you'll see that I forgot to change this I to J which is probably the issue let's go ahead and counts along things out see what we get going here says cannot read property X of undefined this is on line 97 all right so the issue was me being done within our console statement so no worries looks like our code was working all along as soon as we changed this from I to J it's going to save that check things out in our browser and now each time we save the page you'll see that our particles are being randomly generated but they are never being spun on top of each other because we have this catch statement that basically says if these particles are being spawned on top of each other just put it in your location until it's somewhere that's free and that's basically what we're doing right here so each time I save this you'll notice that these particles are never being spawned on top of each other and that is the first step to creating this realistic collision detection effect so while we're at it let's make sure that these particles are always spawned within the boundaries of our canvas as well you'll see that they're overlapping on both the top and the bottom coordinates of our canvas and if we do this enough times you'll see that they're overlapping on the left and right hand side and that is due to this right here so we are saying that this particle can be spun anywhere from zero to our full canvas width and zero to our cold full canvas height but really we want to make sure that it can only spawn from our circles radius to the canvas width minus the radius all right so that might be a little confusing let's go ahead and actually put in code so it can make more sense so we're getting a random value here but we're actually going to be using this utility function random int from range give us a random integer to spawn these so we want to spawn these anywhere from our circles radius so 100 to the canvas width minus the radius and that's going to make sure that these are never overlapping with the left and right hand sides of our screen so since we're using radius in this let's go ahead and push radius up to the top of this and even though we we just added this line of code you'll see well we're still getting overlap well why is it well since we are changing this here and we're regenerating things in case particles are overlapping we aren't running this check here that makes sure that they're being spawned within the canvases boundaries so we want to replace X with this new random generate function like so and now if we do things you'll see that they're never going to be spawned on the left and right hand sides of the screen so I'm actually going to decrease the radius a little bit just make sure we don't run into any issues with these trying to spawn somewhere and not being able to we're going to do the same thing with our y coordinate so we're going to just copy and paste this right here but instead of referencing our canvases width we are going to say spawn anywhere from a circles radius so about right here to our canvases height - the radius which is about right here we're going to take this put it within our Y and if we save that now we have particles generated within our screen always within the canvases boundaries but never overlapping with on the other particles so this is step one we finished up one completely we have everything we need to do step two is we need a way to monitor the distance for each of these individual particles for all the other particles surrounding it so let's use this one particle as a reference I need a way to monitor the distance between this particle and there's particle the distance between this particle and this particle and the distance between this particle and this particle then let's say I select this one right here I need a way to monitor the distance between this particle and this one this one and this one and then this one and this one so we need a way to add collision detection for each of these individual particles monitoring all the particles around it so how do we go about doing that well to do so we're going to head up to our update function and we're actually going to be passing all of our already created particles through this function so this particle right here represents one individual particle but we need a way to compare its distance between all the particles that already exist on the screen so to do so we're going to be passing our particles through as an argument this is an es6 way to pass an argument through a function so we're getting all of our particles and then we're going to be doing collision detection between this individual particle to all the other particles out there so we're going to say for particles that exist particles that length we are going to get the distance between the particles and this particle but since we're passing all of our particles through into this blueprint including this particle itself we want to make sure we're only doing collision detection between this particle and the one surrounding it we don't want to do a collision detection between this particle and itself so to get around this we're going to say if this is equal to particles I so if the particle is equal to itself we are going to skip over this for loop by running continue this is going to make sure we're never comparing a particle to itself which is cool but really we want to do a collision detection between all of the other particles which we shall do so to do a collision detection between all of the other particles we're going to do the same thing that we did down here or a collision detection we're going to grab this if statement bring it on up here paste it in let me fullscreen this make it a little easier for you guys to read and we're going to be grabbing the distance not between an X and a Y variable but this sex it's not lie and then this particles for loop uses I instead of a J so we're going to swap that out so essentially each time we run through this loop we're going to be getting the distance between this particle and all of the surrounding particles as signified right here and if this don't radius times 2 since all our radii are the same this is going to determine whether or not these particles are colliding with each other so if they are colliding let's console out a statement that says has collided and I haven't done them I believe that is how you spell it might have murder that all right so let's see what's going on here we have an area that says property length cannot be defined and that's because we are passing particles through here within our blueprint but we are not actually passing all of our already created particles that we created within this init function we are not passing through our array into our update function like we want to we need to make sure we're actually pushing these particles into our function like so we already created them we're just pushing them through now within an update function so we save things to a heart of fresh curators console errors and now you see we have no errors which is awesome but really these aren't even moving so there's no way for us to actually tell whether or not they have collided so things aren't kind of boring right now let's get these particles moving and then once they touch we should be seeing this console dot log statement to get these particles moving we are going to be adding another property up top called this velocity this is going to be equal to an object with an x and a y velocity so we want to make sure that these particles can go in any direction up down left or right and in order to achieve that we're going to be using math dot random which gives us a random number anywhere from zero to one and we're going to be subtracting 0.5 from it and what this does is it'll go ahead and give us any random value from negative 0.5 to 0.5 and we're going to do the same thing for a y-coordinate make sure that it can move in any direction and we should be good to go there but now we need to actually add this velocity onto our x and y-coordinates so in order to do that right beneath our collision detection check right here we're going to be saying this 2x plus equal to missed on velocity X that's going to add our X velocity on to this current x-coordinate and then we're going to do the same thing for y this stunt velocity dot y and once we save things you'll now see that these particles are moving in random directions and once they collide collide there we go we have our collision detection being activated for all of our individual particles you'll see once it moved off of it it's stopped colliding or it's not logging that has collided console staining so let's go ahead and keep testing the sound let's see if we get multiple particles colliding with each other there we go and these ones are going to collide as well and it should amplify things a little bit getting a lot faster perfect okay so we have our collision detection here across all particles one of the issues you'll see is these particles keep on drifting off the screen which is not really what we want especially when we look at the example over here all the particles are bouncing off the individual boundaries of the screen so it's really easy to fix let's go ahead and do that first before we actually get to other particles bouncing off of one another to actually fix the issue with these particles going off the screen we are going to be using an if statement that says and we've done this in a few other tutorials I believe but nevertheless we are going to be saying if this X - this time radius is less than or equal to zero which means if the circle and it's radius is touching the side of the screen and we want to reverse the X velocity and we are going to be doing the same thing if the circle is touching this side of the screen so we want to say if this x + it's not radius it's greater than or equal to the inner width of our screen we are going to reverse this velocity X let's test that out real quick so you can get them hitting the size error screen okay and it looks like I forgot to actually switch this velocity I'm going to fullscreen things real quick so I can better see the code is kind of hard to see when I have both the browser window and the text editor open at the same time but once this hits the sign of screen whether it be the left or the right we want to reverse the velocity here so we're going to say this velocity the x is negative and once we save that we should get the bouncing off the left on the right hand side I'll keep refreshing till we get something close and there we go that's off the left hand or the right hand side of the screen but we really want to do this for both not only the left and right also the top and parts of the screen so what we can do here is we can just copy and paste this if statement that we just created instead of referencing the X values I'm going to replace them with Y and instead of using the inner width we are going to be using the inner height of our canvas so once we do that and we should get bouncing off both the top bottom left and right hand sides of our screen and we do okay perfect so now we actually want these particles to jump off of each other how do we go about doing that well this is actually quite a complicated process there's a lot of math and physics that goes into this and it can be quite complicated actually wrap your head around I know it took me quite a long time to even get good gist of how this thing works from a high level stand point so we're going to go over things from a high level stand point get things working right off the bat and then I'll do my best to explain things in regards to how this collision detection and reaction is actually working so I'm going to be copying in some utility functions which you can copy in as well there is a gist github gist in the description of the video which has these and let's go ahead and check things out so I've copied in two functions we have a rotate function and we have a resolve collision function so if I go ahead and take this resolve collision function and I go to the spot where our particles are colliding paste it in there you'll see that our resolve collision function takes two particles both objects if I go ahead and push one particle in here this particle itself and then the particle we are comparing the collision detection against the particles I then that should be all we need to get that realistic effect so let's go ahead and save things and see what we get all right all right so you see when they touch they actually just disappear and you'll see the reason for that is because it's a resolved collision function uses mass within it we actually haven't declared anything for our particles mass so let's go ahead and do that now we're going to give our particle all of our particles a massive one and you can't why around with this afterwards but for the sake of this tutorial let's go so go ahead and keep things at one if I go ahead and save this head back on over here you'll see that's all we need for realistic collision detection Andrea this is what we call an elastic collision so elastic collisions mean that when these particles collide no energy is lost to any external forces so the energy is completely maintained across all of the circles all the particles traveling across the screen so how does this function actually work it's really easy to paste in there but what are some of the details behind it well if we look at some of the details I'm going to fullscreen this again you need to understand things from a high-level standpoint how does function actually work what is the process behind creating that realistic reaction that elastic collision well it's really it is quite complicated to understand and I actually drew up some diagrams which I think will help us understand it better so let's go ahead and bring one of those diagrams over here I created a Photoshop you'll see that we have two circles colliding with each other here a blue circle coming from the left to the right and we have a red circle coming from the right to the left well in order to create an accurate reaction to these two circles colliding what variable do we actually need to change between these two circles really it's velocity so we need to change this circles velocity and this circles velocity based on the angle they hit at right here and in order to do so we need to follow a specific algorithm and that algorithm consists of a few things so the first thing I want to go over is equation we're going to use to swap out these two circles velocities with new ones that are going to give an accurate representation of how these two circles collided so that equation is over here and it's called the one-dimensional Newtonian equation I believe that it's what it's called so there's a lot of math here and it can get really confusing but really what we want to happen is we want to call this function right here on our separate velocities but we can only call this function if these two particles right here in these two circles are traveling within one dimension so you'll see right now we have two dimensions we have an X dimension and we have a Y dimension I believe that is correct terminology for it but this this equation that we have that I just showed you the one dimensional in your toe nyan and only works if we're traveling in one dimension that means our circles have to be parallel to each other and traveling from left to right right to left only across the x axis so you can see that this equation right here well work if these two circles are only traveling left or right once we get things in two dimensions that equation isn't going to work we actually have to do a little bit of extra math and what we have to do is we have to rotate things by this angle right here the angle created by the collision between the two objects so drawing a right triangle we get an angle but then we need to actually rotate things by the angle so if we rotate things like so we can now run that one-dimensional equation on these two circles based on their velocities so once we run that equation we're going to get the new velocities for them but then we need to translate things back by re rotating things back to their original positioning like so and I believe that is zero so that is essentially the gist behind creating this realistic reaction so let's go ahead and look at the code real quick and see if we can draw some parallels between the code and the diagram and the equation that we just went over so starting off the first thing we need to do is prevent any accidental overlap of particles so this is grabbing a difference in velocity and distance on both the x and y components of the two particles that were passing through and if this is equal to zero this is the only time we're actually going to react to the collision if we don't have this here we get a lot of room for error we have an effect that might occur in which the particles actually connect to each other stick to each other and don't bounce so we need to make sure that we have this prevent any accidental overlap second we are grabbing the angle between our two colliding particles the particle and other particle and if we look at our model over here you'll see that we have two colliding particles and this is the angle that's created between two so based on the X&Y positioning of this protocol and the X&Y positioning of this particle we can grab the angle by using this function right here arctangent - so we're grabbing the angle and then we're rotating our particles velocities we're rotating the coordinate system by that angle so when we run this right here rotate we're rotating our coordinate systems like so so now we have things on one dimension we can use that one-dimensional collision equation and that is what we're doing next we're running that complete equation that you saw in Wikipedia let's bring that up you'll see that we have the initial velocity right here which is U we have the mass - other mass and then we have a few more extra things in order to get an accurate representation of the collision you can see this matches up directly with what we have right here we're doing this only for the x coordinate we don't need to do this for the Y because we are only using things on the x axis so finally we are going to rotate things backwards once we get a result for that so back to our original coordinate system like so and you can see we're doing that right here we're just reversing the angle in which we rotated things by and finally we are swapping our particles velocities with the new velocities that we just attained by running things through our one-dimensional collision equation and with all of that that is how we produce the effect of all these particles bouncing off of each other so that's the general gist of how this equation works from a high-level standpoint like I said we could get into this a lot more detailed that's something you guys are interested in please let me know and I might be able to write a blog post on it but really that should give you enough to be dangerous with this equation and get your particles moving and bouncing realistically off of each other so we're not done just yet if we look at the example you can see that we had a few more things I'm going to pull that up real quick our particles are bouncing off of each other but they're moving at different speeds they're different sizes and they're different colors and we also have this effect where if we hover our mouse over the particles well the particles are changing their opacity or at least the fill opacity so let's go ahead and get let's just go ahead and start things off with getting them the right size and getting them moving at a quicker speed and also getting them colored and then we'll go ahead and add the inner activity so to go ahead and add more particles to this we're going to head down to in it and rather than four particles let's just say we want to add 100 we need to make sure we're changing the radius to this if we are have these all spot on the screen accurately without getting stuck in a constant loop so we're going to say raise to 15 and now we have all of our particles on the screen which is cool but now we want to be able to change the actual speed in which these particles aren't moving so we're going to head back on up to velocity and get a random value anywhere from negative 5 actually I believe this is a random value from negative two point five to two point five I believe that is correct reckoning if I'm wrong essentially this is going to increase our velocities in which our circles can be spotted and now we have something a lot more a lot closer to what we saw with in the example alright but right now everything is the same color changing color these get them something random is really easy I'm a utility function called random color this just takes an array of colors which we have up here and it's going to return to us a random color based on whatever colors we pass through so if we scroll on down you'll see our color is currently hard-coded to blue we want a random color from our colors array and just like that and we now have colors all over the place and there's a really light color in there which I'm not really a huge fan of I believe it is which color is it I believe it's this one right here I'm going to delete it yes that was it so now all of our particles are colored which is nice but now we need to add collision detection between our mouse in each of these individual particles so just like we did with everything else let's go ahead and do that now I'm going to full screen this again and within this collision types of stuff with the wall boundaries we're going to add Mouse collision detection we are going to say if the distance so I'm going to grab this right here if the distance between our Mouse's x-coordinate and our mouse is y coordinate and this coordinates x and this coordinates Y is less than let's just say 31 let's console.log things out let's just say console.log collided alright cool so we're going to see if this works and each time we hover over one of these we are now calling our constant log of kaleidos so a really easy way to do collision detection between our mouse and each of the individual particles on the screen but nothing's happening just yet with the background color of our particles so what we want to do is we want to head on down here and create a fill for our particles we're going to say C dot fill and before that we are going to say C that fill style is equal to this dot color and that's going to fill things in let's go and look at it see all of our particles are now colored in but we want to make sure that these particles have an opacity for their fill style which only increases if we're hovering over them so to do that I'm fullscreen things again there are a few ways to do this including using RGB a values but I think the easiest way is to stick with hexadecimal values and edit the global opacity of our canvas instead so if we want to go ahead and change the opacity of our fill color we can say something like see that global alpha is equal to 0.2 save that and that's going to change the opacity of our entire canvas to zero point two and let's go ahead and check that out see everything is really light now but the the borders of our circle should be dark so how do we solve this issue to solve this issue we are going to be calling something called C dot save and this is going to save the current state of our canvas at this specific point in time and then after we call fill to fill in our circles we're going to say C dot restore so what this is doing is we're saving our current state of our canvas and then we are decreasing our alpha for just the fill to zero point two and we know that we're just doing it for the fill because fill is contained within the save and restore function but once we do that only the fill for a background has a letter opacity really we want to add interaction so when we move our mouse over this we are getting this opacity increased over time so rather than just hard code and opacity of 0.2 we are going to say it's opacity you should be equal to this not opacity so each individual particle is going to have its own individual property which controls how light it is on the screen so we can say this down opacity is going to start off at zero so there shouldn't be a fill which is perfect but now we want to actually increase this when the distance of our mouse is hovered over one of these actual particles so what we can do is we can say this opacity Plus Eagle to 0.02 and I should get things filled up you'll see now they are starting to fill up very slowly I guess not that slow but they're starting to fill up over time and the issue here now is that whenever we hover off of them they're not going back to their original state and we might want to restrict the opacity in which these particles can actually go too so let's go ahead and do that let's make sure they can only go to somewhat of a lighter value but not all the way to full opaque to restrict the opacity in which these particles can go too we are going to be adding an and statement here it says only call this only increase opacity if they start opacity it's less than or equal to and actually let's just do less than is less than 0.2 that's going to restrict things make sure that they can only go up to a light opacity which you can see here they're not filling in all the way which is perfect but now we want to make sure that they get lighter as our mouse hovers off of them so we're going to add an else if says if this dot opacity is greater than zero you subtract 0.02 from this opacity instead so we gonna check things out now see that we're getting a really really weird bug and the reasoning for this is when we are subtracting 0.02 we can log this out really quickly we're going to be getting some values that don't really make sense and this is some an issue with the equation of subtracting floats from each other in JavaScript so we want to make sure that our opacity can never go below zero and to do that we can say this not opacity should never go below a value of zero or itself misdialed Pasi so this is going to contain things within a boundary of zero to point two and once we do that we should get rid of that bug with the circles filling in all the way which we do but you see if we look at the example over here we have a much larger radius in which we can hover over these circles to have them fill in so let's go ahead and do that all we have to do to increase the radius is increase this number right here so let's go ahead and give it a radius of 80 which means whenever a mouse is within 80 pixels of a circle it's going to fill in and if we save that and look at our screen you'll now see we have a much larger radius in which our mouse can get close to circles and fill them in but it's not perfect so let's go ahead and say 120 so that's going to cover things up for this video guys I hope you enjoyed we learned a lot about math physics and a lot about collision detection if you would like support go ahead subscribe leave a like and share with your friends go ahead and donate to me over on patreon if you would like every donation I get helps a ton I can't tell you how much it really helps towards me being able to produce more of these videos otherwise I hope you guys had a great day I look forward to seeing you in the next video stay tuned for next week peace [Music]		