in my previous video I showed the conversion of my CPU to VHDL this time I'll show the usage of evolution to convert my CPU to vera log so as not to be redundant and for viewers who have seen my VHDL video I'll skip some of the introductory stuff and circuit prep please refer to my VHDL video if you need to as stated in my previous video the reason to do the conversion is that in order to put your design into a field programmable gate array or FPGA you need to code it in a language such as VHDL or Verilog once it's in an FPGA you can use your design in the real world so to speak before I show the conversion I'll show a new feature of my design I created an assembly instruction TTY jar library it's connected to the instruction register and shows the instruction currently being executed by interpreting the IR value it shows the Z register value in hexadecimal decimal an ASCII character if applicable I decided to do things differently in this video so it won't be boring for those who saw my VHDL video this time I'll fix as much as possible in the circuit before creating the code rather than fixing it in the code and later I'll use a different program for editing and another version of evolution and all Tara's Quartus prime IDE so be sure to watch all of this video evolutions 32-bit ROM bug that I pointed out in my previous video only affects the VHDL code not Vera log there is however another 32-bit ROM bug if the 32nd bit of any of the ROM contents is set that value will be a negative number my control rom never sets that bit so I don't need to deal with that bug here my tests show that in the case of ROM contents negative values are not a problem at least with the Vera log compilers I use I fixed the 32 bit counter max Val bug by making the counter 31 bits I had to use splitters to convert between 32 and 31 bit I fixed the two input priority encoder bug by making the encoder for input with the two new inputs zero now all my encoders are for input and I fixed my unconnected line bug by connecting it to zero evolution will tell you if it can convert a given component to VHDL and Verilog note the green for convertible and red for not convertible to use evolutions conversion process you should remove anything not convertible as with VHDL for Vera Log I had to remove the divider now for just Vera log I have to remove the multiplier this is what I'll run through the FPGA commander you can choose the board you have if yours is not listed you can try to add it yourself I'll use FPGA for you just for the heck of it clicking annotate will add labels to any unlabeled components in some circuits everything has to be called something download creates the code now the unmet buttons and LEDs need to be mapped to the desired components on your board your options are highlighted in red select which one you want to assign look at any errors or warnings that pop up I don't know how to deal with the gated clock warnings so that could be a problem I would have to tackle in the actual FPGA implementation also you can click on the red arrow icons to go right to the offending parts it's not really practical to teach Oliveira login this video so I'll just cover some basics and things to look out for when using evolutions generated very long code except for the use of begin and end and some keywords ver log is similar to C wire reg integer and a few other data types all do similar things but there are rules about which can be used we're generally speaking use wire to connect things and reg to store data in an always or initial block and in procedures wires can only be used for combinational logic rigs can be used for either combinational or sequential logic there are also blocking assign which are denoted by just in equals and non-blocking assignments which are denoted by a less than equals with a non-blocking assignment the assignment takes place once the always block has finished with a blocking assignment the assignment takes place immediately processes can be declared with initial or always the initial block is a special case of an always block an initial block only runs once every always an initial block once concurrently meaning in parallel and always performs the operations in the block once the conditions in the sensitivity list are met statements inside procedures and functions run sequentially unfortunately evolution does have some bugs specific to Vera log for one thing the counter doesn't seem to work if it's a rising edge counter I don't fully understand evolutions generated counter code but I found commenting out the conditional in the positive edge clock trigger section solves the problem I don't know what bad effects if any this might cause the next bug is with the subtractor code evolution does the subtraction in a weird way I believe they forgot to factor in two's complement each negation needs to add one after negating so I could just add two in order to get the correct result but I think I'll just do it the normal way instead using a minus now to add in what I had to take out to make the conversion process work rather than edit it now in this video I'll describe what had to be done I had to add the multiplier and divider components to the ALU then I added three new signal lines from the output of the multiplier and divider to go to the input line numbers two three and eight the values were zero before then I created the multiplier file guessing at what it should be then her file I had to guess how to implement a divider and they only implemented what my cpu design needed other CPU designs might need to more fully implement a divider I also had to handle division by zero I chose to do the same thing evolution does in that case setting the result to be the same as the dividend and the remainder to be zero since I'm not testing this on an actual FPGA for you board I don't need the top level and base fare log code that evolution creates and I don't really need the CPU zero code since that is somewhat redundant but I do need to write a test bench to call the CPU component there are no parameters in this file since this will be the top level I declare the wires needed I declare the regs needed I create an initial process that runs the test it creates the VCD output file resets and starts the CPU and runs the clock the pound sign specified delays if the opcode is the data in instruction I want to read from the keyboard and if the CPU is ever in the halted state I want to end the simulation early and finally I instantiate the CPU and program components pairing the parameters with the wires and regs now the program in memory code this time there are module parameters I declare the type and size of the parameters I create the memory bank holding the program and RAM I split the address into separate wire pieces to reduce what has to be typed I create an initial process to read the program from the file prog draw and then end then I create an always block that gets triggered on the falling edge of the write enable line this block is for the rights to the devices it just outputs to the screen what would go to the devices then I create an always block that also gets triggered on the falling edge of the right naval line this lock writes to the RAM I could have combined these two blocks unlike VHDL v√©ra log does let me modify the contents of the memory bank where the program resides so I don't need to separate thanks I set the output of the memory I chose to use the free Ikaros Verilog program to compile the code if you have an fpga board most likely you'll have a VHDL and Verilog IDE and compiler specific to that board you would probably want to use that here's the batch file I created to compile it now I'll compile it to run it you use Icarus ver logs vvp program ignore the warning messages they just say the program isn't the same exact size as the memory with my very long test bench implementation I don't have to type the desired options twice like I had to with VHDL you can see what would be sent to the devices now I'll use the free gtk wave program to display the waveform traces of any lines I desire here's the batch file I wrote to run it you can select which lines you want to see I'll now assume to see more of the range and look through all of the values as it ran the program well it's great that it worked from what I read getting a design to be ready to be put in an FPGA involves a little more work you have to deal with whatever gate delay timing issues or other timing constraints that might arise as well as any peculiarities of the particular FPGA board and other design issues you might need to use the specific software that came with your Lord to work those out by the way both sigh links and Altera have free scaled-down versions of their software if you want to give those a try I'll be showing all Terra's software later in this video now I'll show a different version of logis in evolution this one is done by Kevin Walsh who is the offer of the Cornell components I've mentioned in other videos one nice feature of his version is the easy ability to switch between original larger sims memory components appearance and evolutions appearance you can see how useful this would be another nice feature is the fully automated process of synthesizing and downloading to an FPGA board using either altaira or Xilinx programs to make things easier i put the program that the cpu will run in Iram if you use ram make sure you wire up the right Nabal line otherwise your cpu will probably be optimized out this is because if it realizes a particular path isn't used or is always constant etc it will optimize it out by the way I used the smallest size ROM that my program would fit in to make it optimized faster it will take longer to optimize and synthesize a ROM then I ran since I only downloaded the cyclone 4 device library I'll choose the Jurassic de 0 nano board the first time you use this process in a given session you need to put in the location of your Altera or die links program the optimization and synthesize a ssin process can take quite a while if your circuit uses a clock but you'll get a warning about no clocks in the design that's a pretty good indication your design has been optimized out since I don't currently have a de zero nano board connected it will give an error in the downloading process there is a problem with the automated process though if there are any evolution VHDL or Verilog generation bugs and we know there are there's no way to change the generated code before it goes through to the optimization and synthesize a ssin process same thing applies if you needed to manually put in what evolution couldn't convert such as a multiplier and a divider if you are using VHDL as the intermediate language between evolution and the synthesizer which by the way Kevin Walsh recommends since the VHDL conversion code has been worked on more you can use a feature of evolution to add a VHDL component to your design the other evolution distribution has this feature as well but you might have to enable it by going to the project menu then load library selecting built-in library and choosing HDL IP if the VHDL validate button isn't selectable your VHDL code past some basic validation tests I believe you have to have both the entity and architecture sections in the same file once you've created the VHDL component it can be wired up just like any other component however it won't simulate like normal in la jusen maybe if you have questa it will I don't know but it will be used when your designs VHDL code is generated you could also load the evolution created files into your poured software before or after you edit the generated VHDL or Verilog code as needed look in the sandbox directory for the project file which is a qpf file in the case of Altera by the way the QSF file contains some useful information now I'll show all Terra's Quartus software this is the free version it's a lot more complicated than gee HDL icarus Verilog and Teek a wave but those can't create a bit stream to send to an fpga board now i'll show notepad plus plus which i've used in this video to do the editing as you can see it highlights various programming constructs in different colors you can also click the minus and plus buttons to hide or show any particular block of the code another feature is predicting what you might be typing keywords procedure names variables whatever you can select from the list also once an indented block has been started it will automatically indent the next line in case you're wondering how it knows how to do all this it has settings for many different languages including VHDL and Verilog if you've used various programming IDE s these capabilities will be familiar and if you don't like the color theme you can choose many others by the way I changed the settings of the theme used in this video by choosing a bigger font to make it a little easier for people viewing this video on a cell phone at any rate I'm very adept with the eye so I guess I'll keep using VI but I can definitely see how useful notepad plus plus is well I've potentially given you a lot to explore I hope I've given you all the information you'll need to design whatever you want happy exploring		